Objc {

Exp 
  = ExternalDeclaration+
  
macro
  = "TMLLocalizedString"
  | "TMLLocalizedAttributedString"
  | "TMLLocalizedDate"
  | "TMLLocalizedAttributedDate"
  
NonEmptyListOf<elem, sep>
  = elem (sep elem)*

ExternalDeclaration
  = comment 
  | lineComment 
  | PreprocessorDeclaration
  | FunctionDefinition
  | Declaration 
  | ClassInterface
  | ClassImplementation
  | CategoryInterface
  | CategoryImplementation
  | ProtocolDeclaration
  | ProtocolDeclarationList
  | ClassDeclarationList

PreprocessorDeclaration
  = Import | Include

ClassInterface
  = "@interface" className (":" superClassName)?
	ProtocolReferenceList?
	InstanceVariables?
	InterfaceDeclarationList?
	"@end"

CategoryInterface
	= "@interface" className "(" categoryName? ")"
	ProtocolReferenceList?
	InstanceVariables?
	InterfaceDeclarationList?
	"@end"

ClassImplementation
	= "@implementation" className ( ":" superClassName )?
	InstanceVariables?
	ImplementationDefinitionList?
	"@end"

CategoryImplementation
	= "@implementation" className "(" categoryName ")" 
  ImplementationDefinitionList? 
  "@end"

ProtocolDeclaration
	= "@protocol" protocolName ProtocolReferenceList?
	"@required"? InterfaceDeclarationList? 
  "@optional"? InterfaceDeclarationList?
	"@end"

ProtocolDeclarationList
	= "@protocol" ProtocolList ";"

ClassDeclarationList
	= "@class" ClassList ";"

ClassList
	= ListOf<className, ",">

ProtocolReferenceList
	= "<" ProtocolList ">"

ProtocolList
	= ListOf<protocolName, ",">

PropertyDeclaration
  = "@property" PropertyAttributesDeclaration? StructDeclaration

PropertyAttributesDeclaration
  = "(" PropertyAttributesList ")"

PropertyAttributesList
  = NonEmptyListOf<PropertyAttribute, ",">

PropertyAttribute
  = constantPropertyAttribute
  | GetterPropertyAttribute
  | SetterPropertyAttribute
  | identifier

constantPropertyAttribute
  = "nonatomic" | "assign" | "weak" | "strong" | "retain" | "readonly" | "readwrite"
  
GetterPropertyAttribute
  = "getter" "=" identifier
  
SetterPropertyAttribute
  = "setter" "=" identifier ":"

className
	= identifier

superClassName
	= identifier

categoryName
  = identifier

protocolName 
  = identifier

InstanceVariables
  = "{" visibilitySpecification StructDeclaration+ InstanceVariables "}" --visibilityStructVars
  | "{" StructDeclaration+ InstanceVariables "}"  --structVars
  | "{" visibilitySpecification StructDeclaration+ "}" -- visibilityStruct
  | "{" StructDeclaration* "}"  --struct

visibilitySpecification
	= "@private"
	| "@protected"
	| "@package" 
	| "@public"

InterfaceDeclarationList
  = InterfaceDeclaration+
  
InterfaceDeclaration
  = Declaration 
  | ClassMethodDeclaration
  | InstanceMethodDeclaration 
  | PropertyDeclaration

ClassMethodDeclaration
  = "+" MethodDeclaration

InstanceMethodDeclaration
  = "-" MethodDeclaration

MethodDeclaration
	= MethodType? MethodSelector ";"

ImplementationDefinitionList
  = (FunctionDefinition
  | Declaration 
  | ClassMethodDefinition 
  | InstanceMethodDefinition
  | PropertyImplementation)+

ClassMethodDefinition
  = "+" MethodDefinition

InstanceMethodDefinition
  = "-" MethodDefinition
	
MethodDefinition
	= MethodType? MethodSelector InitDeclaratorList? ";"? CompoundStatement

MethodSelector
	= KeywordDeclarator+ ParameterList? --withParams
  | selector

KeywordDeclarator
	= selector? ":" MethodType* identifier

selector 
  = identifier

MethodType
  = "(" TypeName ")"

PropertyImplementation
  = "@synthesize" PropertySynthesizeList ";"
  | "@dynamic" PropertySynthesizeList ";"

PropertySynthesizeList
  = ListOf<PropertySynthesizeItem, ",">

PropertySynthesizeItem
  = identifier "=" identifier --full
  | identifier 

BlockType
  = TypeSpecifier "(" "^" TypeSpecifier? ")" BlockParameters?

GenericsSpecifier
  = "<" (TypeSpecifier)? ("," TypeSpecifier)* ">"

TypeSpecifier
	=	EnumSpecifier --enum
	|	StructOrUnionSpecifier --structOrUnion
  | typeSpecifierKeyword  --keyword
	|	"id" ProtocolReferenceList? --generic
  | "typeof" "(" Expression ")" --typeof
  |	className ( ProtocolReferenceList | GenericsSpecifier )? Pointer? --classed
  
intSpecifier
  = ("int" | "Int" | "INT") (digit* "_" letter+)?
  
typeSpecifierKeyword
  = "void" | "char" | "short" | intSpecifier | "long" | "float" | "double" | "signed" | "unsigned" | "instancetype"

typeQualifier
	= "const" | "volatile" | protocolQualifier

protocolQualifier
	= "in" | "out" | "inout" | "bycopy" | "byref" | "oneway"

PrimaryExpression
  = BlockExpression
  | BoxExpression
  | ArrayExpression
  | DictionaryExpression
	| EncodeExpression
	| ProtocolExpression
	| SelectorExpression
	| MessageExpression
  | "super"
	| "self"
	| "(" Expression ")" --inParens
	| stringLiteral
	| constant
	| identifier

DictionaryPair
  = PostfixExpression ":" PostfixExpression

DictionaryExpression
  = "@" "{" DictionaryPair? ("," DictionaryPair)* ","? "}"

ArrayExpression
  = "@" "[" PostfixExpression? ("," PostfixExpression)* ","? "]"

BoxExpression
  = "@" "(" ConditionalExpression ")" --conditional
  | "@" constant --constant
        
BlockParameters
   = "(" (TypeVariableDeclarator | TypeName | "void")? ("," (TypeVariableDeclarator | TypeName))* ")"

BlockExpression
  = "^" TypeSpecifier? BlockParameters? CompoundStatement

MessageExpression
	= "[" Receiver MessageSelector "]"

Receiver
	= Expression
	| className 
	| "super"

MessageSelector
	= KeywordArgument+
	| selector

KeywordArgument
	= selector? ":" Expression

SelectorExpression
	= "@selector" "(" selectorName ")"

selectorName
	= (selector? ":")+ --withArg
	| selector

ProtocolExpression
	= "@protocol" "(" protocolName ")"

EncodeExpression
	= "@encode" "(" TypeName ")"

TypeVariableDeclarator
	= DeclaratorSpecifierFor<Declarator>+ Declarator

TryStatement
	= "@try" CompoundStatement

CatchStatement
	= "@catch" "(" TypeVariableDeclarator ")" CompoundStatement

FinallyStatement 
  = "@finally" CompoundStatement

ThrowStatement 
  = "@throw" "(" identifier ")"

TryBlock 
  = TryStatement ( CatchStatement )* ( FinallyStatement )?

SynchronizedStatement 
  = "@synchronized" "(" PrimaryExpression ")" CompoundStatement

AutoreleaseStatement 
  = "@autoreleasepool" CompoundStatement

FunctionDefinition 
  = DeclaratorSpecifierFor<Declarator>* Declarator CompoundStatement

Declaration 
  = DeclaratorSpecifierFor<DeclarationExpression>+ DeclarationExpression --normal
  | DeclaratorSpecifierFor<EnumSpecifier>+ EnumSpecifier DeclarationExpression --enum
  
DeclarationExpression
  = InitDeclaratorList? ";"
  
DeclaratorSpecifierFor<Specified>
	= DeclarationSpecifier &Specified
  | DeclarationSpecifier &DeclaratorSpecifierFor<Specified>

DeclarationSpecifier 
  = TypelessDeclarationSpecifier
  | TypeSpecifier
  
TypelessDeclarationSpecifier
  = arcBehaviourSpecifier 
  | storageClassSpecifier 
  | typeQualifier

arcBehaviourSpecifier
  = "_UnsafeUnretained" | "_Weak" | "__weak" | "__strong"

storageClassSpecifier 
  = "auto" | "register" | "static" | "extern" | "typedef"

InitDeclaratorList 
  =	NonEmptyListOf<InitDeclarator, ",">

InitDeclarator 
  = Declarator ("=" Initializer)?

StructOrUnionSpecifier 
  = ("struct" | "union") identifier? "{" StructDeclaration+ "}" --withDeclaration
  | ("struct" | "union") identifier --simple

StructDeclaration 
  = SpecfierQualifierFor<StructDeclaratorList>+ StructDeclaratorList ";"
  
SpecifierQualifier
  = arcBehaviourSpecifier 
  | TypeSpecifier 
  | typeQualifier
  
SpecfierQualifierFor<Specifier>
  = SpecifierQualifier &Specifier

StructDeclaratorList 
  = NonEmptyListOf<StructDeclarator, ",">

StructDeclarator 
  = Declarator? ":" constant --withConstant
  | Declarator --simple

EnumSpecifier 
  = "enum" (":" TypeName)? identifier ("{" EnumeratorList "}")? --enumWithIdentifier
  | "enum" (":" TypeName)? "{" EnumeratorList "}" --enum
  | ("NS_OPTIONS"|"NS_ENUM") "(" TypeName "," identifier ")" "{" EnumeratorList "}" --nsenum

EnumeratorList 
  = NonEmptyListOf<Enumerator, ","> ","?

Enumerator 
  = identifier ("=" ConstantExpression)?

Pointer
  = "*" TypelessDeclarationSpecifier* Pointer --compound
  | "*" TypelessDeclarationSpecifier* --simple

Declarator 
  = Pointer? DirectDeclarator

DirectDeclarator 
  = "(" "^" identifier? ")" BlockParameters --block
  | "(" Declarator ")" DeclaratorSuffix* --withDeclarator
  | identifier DeclaratorSuffix* --withIdentifier


DeclaratorSuffix 
  = "[" ConstantExpression? "]"
  | "(" ParameterList? ")"

ParameterList 
  = ParameterDeclarationList ( "," "..." )?

ParameterDeclaration 
  = DeclaratorSpecifierFor<ParameterDeclarationExpression>+ ParameterDeclarationExpression
  
ParameterDeclarationExpression
  = AbstractDeclarator
  | Declarator?

Initializer 
  = "{" NonEmptyListOf<Initializer, ","> ","? "}" --compound
  | AssignmentExpression --simple

TypeName 
  = BlockType --block
  | SpecfierQualifierFor<AbstractDeclarator> AbstractDeclarator --declaration

AbstractDeclarator 
  = "(" AbstractDeclarator ")" AbstractDeclaratorSuffix+ --compound
  | ("[" ConstantExpression? "]")+ --constantExpression
  | Pointer AbstractDeclarator --normal
  | --empty

AbstractDeclaratorSuffix
  = "[" ConstantExpression? "]"
  | "(" ParameterDeclarationList? ")"

ParameterDeclarationList
  = NonEmptyListOf<ParameterDeclaration, ",">

StatementList 
  = Statement+

Statement 
  = LabeledStatement
  | Expression ";" --expression
  | CompoundStatement
  | SelectionStatement
  | IterationStatement
  | JumpStatement
  | SynchronizedStatement
  | AutoreleaseStatement
  | TryBlock
  | ";"

LabeledStatement
  = "default" ":" Statement --default
  | "case" ConstantExpression ":" Statement --case
  | identifier ":" Statement --identifier

CompoundStatement 
  = "{" (Declaration | StatementList)* "}"

SelectionStatement
  = "if" "(" Expression ")" Statement ("else" Statement)? --ifelse
  | "switch" "(" Expression ")" Statement --switch

ForInStatement 
  = "for" "(" DeclaratorSpecifierFor<DeclaratorInExpression>+ DeclaratorInExpression ")" Statement
  
DeclaratorInExpression
  = "in" Expression?

ForConditional
  = DeclaratorSpecifierFor<InitDeclaratorList>+ InitDeclaratorList --declaration
  | Expression --expression

ForStatement 
  = "for" "(" ForConditional? ";" Expression? ";" Expression? ")" Statement
  
WhileStatement 
  = "while" "(" Expression ")" Statement
  
DoStatement
  = "do" Statement "while" "(" Expression ")" ";"

IterationStatement
  = WhileStatement
  | DoStatement
  | ForStatement
  | ForInStatement

JumpStatement
  = "goto" identifier ";" --goto
  | "continue" ";" --continue
  | "break" ";" --break
  | "return" Expression? ";" --return

Expression 
  = NonEmptyListOf<AssignmentExpression, ",">

AssignmentExpression
  = UnaryExpression assignmentOperator AssignmentExpression --expression
  | ConditionalExpression --conditional

assignmentOperator
  = "=" | "*=" | "/=" | "%=" | "+=" | "-=" | "<<=" | ">>=" | "&=" | "^=" | "|="

ConditionalExpression 
  = LogicalOrExpression ("?" ConditionalExpression ":" ConditionalExpression)?

ConstantExpression 
  = ConditionalExpression

LogicalOrExpression 
  =	NonEmptyListOf<LogicalAndExpression, "||">

LogicalAndExpression 
  = NonEmptyListOf<InclusiveOrExpression, "&&">

InclusiveOrExpression 
  = NonEmptyListOf<ExclusiveOrExpression, "|">

ExclusiveOrExpression 
  = NonEmptyListOf<AndExpression, "^">

AndExpression 
  = NonEmptyListOf<EqualityExpression, "&">

EqualityExpression 
  = NonEmptyListOf<RelationalExpression, EqualityOperator>
  
EqualityOperator
  = "!=" | "=="

RelationalExpression 
  = NonEmptyListOf<ShiftExpression, RelationalOperator>
  
RelationalOperator
  = "<" | ">" | "<=" | ">="

ShiftExpression 
  = NonEmptyListOf<AdditiveExpression, ShiftOperator>
  
ShiftOperator
  = "<<" | ">>"

AdditiveExpression 
  = NonEmptyListOf<MultiplicativeExpression, AdditiveOperator>
  
AdditiveOperator
  = "+" | "-"

MultiplicativeExpression 
  = NonEmptyListOf<CastExpression, MultiplicationOperator>
  
MultiplicationOperator
  = "*" | "/" | "%"

CastExpression 
  = "(" TypeName ")" CastExpression --typed
  | UnaryExpression --unary

UnaryExpression 
  = PostfixExpression --postfix
  | ("++"|"--") UnaryExpression --preOpUnary
  | unaryOperator CastExpression --cast
  | "sizeof" "(" TypeName ")" --sizeAndType
  | "sizeof" UnaryExpression --sizeAndExpression

unaryOperator 
  = "&" | "*" | "-" | "~" | "!"

PostfixExpression 
  = PrimaryExpression PostfixExpressionSuffix*
  
PostfixExpressionSuffix
  = "[" Expression "]" --expression
  | "(" ArgumentExpressionList? ")" --argumentExpressionList
  | "." identifier --dotIdent
  | "->" identifier --arrowIdent
  | "++"
  | "--"

ArgumentExpressionList
  = ListOf<AssignmentExpression, ",">

constant 
  = floatingPointLiteral
  | characterLiteral 
  | octalLiteral 
  | hexLiteral 
  | decimalLiteral 

identifier
	=	letter (letter | digit)*
	
letter
	+= "$"
	|	"_"
  
characterSequence
  = escapeSequence --escaped
  | ~("\"" | "\\") any --notEscaped

characterLiteral
  = "\"" characterSequence "\""

stringLiteral 
  = "@" string

string 
  = "\"" characterSequence* "\""

hexLiteral 
  = "0" ("x" | "X") hexDigit+ integerTypeSuffix?

decimalLiteral 
  = "0" integerTypeSuffix? --zero
  | "1".."9" "0".."9"* integerTypeSuffix? --nonZero

octalLiteral 
  = "0" ("0".."7")+ integerTypeSuffix?

integerTypeSuffix
	=	"u" | "U" | "l" | "L"

floatingPointLiteral
  = digit+ ("." digit*)? exponent? floatTypeSuffix?

exponent 
  = ("e"|"E") ("+"|"-")? digit+

floatTypeSuffix 
  = "f" | "F" | "d" | "D"

escapeSequence
  = "\\" ("b" | "t" | "n" | "f" | "r" | "\"" | "\'" | "\\") --nonOctal
  | octalEscape --octal

octalEscape
  = "\\" "0".."3" "0".."7" "0".."7" --long
  | "\\" "0".."7" "0".."7" --medium
  | "\\" "0".."7" --short

unicodeEscape
  = "\\u" hexDigit hexDigit hexDigit hexDigit

// Import/include

Import 
  = "#import" (string|angleString) --hashed
  | "@import" string ";" --modern
  
Include 
  = "#include" (string|angleString)
  
angleString 
  = "<" (~">" any)* ">"
  
// Other preprocessor directives
  
pragma 
  = "#pragma" (~newLine any)*
  

// Comments

comment 
  = "/*" (~"*/" any)* "*/"
    
newLine 
  = "\r" | "\n"

lineComment 
  = "//" (~newLine any)*
  
space
  += comment | lineComment | pragma | preprocessorDirective

// Pre-processor defines

preprocessorDirective
  = hdefine | hifd | hif | helif | helse | hundef | hifndef | hendif 

hdefine 
  = "#define" (~newLine any)*
hif 
  = "#if" (~newLine any)*
hifd 
  = "#ifdef" (~newLine any)*
helif 
  = "#elif" (~newLine any)*
helse 
  = "#else" (~newLine any)*
hundef 
  = "#undef" (~newLine any)*
hifndef 
  = "#ifndef" (~newLine any)*
hendif 
  = "#endif" (~newLine any)*

}